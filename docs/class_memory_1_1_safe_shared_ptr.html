<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cpp Utilities: Memory::SafeSharedPtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cpp Utilities
   &#160;<span id="projectnumber">1.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_memory.html">Memory</a></li><li class="navelem"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="class_memory_1_1_safe_shared_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Memory::SafeSharedPtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Wrapper to <code>std::shared_ptr</code> to provide thread-safety while operating the underlying pointer.  
 <a href="class_memory_1_1_safe_shared_ptr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_safe_shared_ptr_8hpp_source.html">SafeSharedPtr.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_array_helper.html">ArrayHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class for operator[] in <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>, behave like array element of underlying array object, and provide RAII read-write lock for thread safety.  <a href="class_memory_1_1_safe_shared_ptr_1_1_array_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ptr_helper.html">PtrHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class for operator-&gt; in <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>, behave like underlying object, and provide RAII read-write lock for thread safety.  <a href="class_memory_1_1_safe_shared_ptr_1_1_ptr_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ref_helper.html">RefHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy class for operator* in <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>, behave like underlying object, and provide RAII read-write lock for thread safety.  <a href="class_memory_1_1_safe_shared_ptr_1_1_ref_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afee9452fe9852f8e57a86cf8f3124b89"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#afee9452fe9852f8e57a86cf8f3124b89">ReadWriteLock</a> = std::shared_mutex</td></tr>
<tr class="memdesc:afee9452fe9852f8e57a86cf8f3124b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to <code>std::shared_mutex</code> with C++17 or higher, otherwise defined to <a class="el" href="class_memory_1_1_r_w_spin_lock.html" title="High-performance read-write-spinlock, see RWSpinLock.hpp for details.">RWSpinLock</a>.  <a href="#afee9452fe9852f8e57a86cf8f3124b89">More...</a><br /></td></tr>
<tr class="separator:afee9452fe9852f8e57a86cf8f3124b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94dd72f327e72c8aff63ab8a97b0895e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a94dd72f327e72c8aff63ab8a97b0895e">SharedLock</a> = std::shared_lock&lt; std::shared_mutex &gt;</td></tr>
<tr class="memdesc:a94dd72f327e72c8aff63ab8a97b0895e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to <code>std::shared_lock&lt;std::shared_mutex&gt;</code> with C++17 or higher, otherwise defined to <a class="el" href="class_memory_1_1_r_w_spin_lock_1_1_read_holder.html" title="RAII guard for read lock with RWSpinLock::lock_shared() on construction and RWSpinLock::unlock_shared...">RWSpinLock::ReadHolder</a>.  <a href="#a94dd72f327e72c8aff63ab8a97b0895e">More...</a><br /></td></tr>
<tr class="separator:a94dd72f327e72c8aff63ab8a97b0895e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3073aba790f930cb0036209d01c74e52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a3073aba790f930cb0036209d01c74e52">UniqueLock</a> = std::unique_lock&lt; std::shared_mutex &gt;</td></tr>
<tr class="memdesc:a3073aba790f930cb0036209d01c74e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to <code>std::unique_lock&lt;std::shared_mutex&gt;</code> with C++17 or higher, otherwise defined to <a class="el" href="class_memory_1_1_r_w_spin_lock_1_1_write_holder.html" title="RAII guard for write lock with RWSpinLock::lock() on construction and RWSpinLock::unlock() on destruc...">RWSpinLock::WriteHolder</a>.  <a href="#a3073aba790f930cb0036209d01c74e52">More...</a><br /></td></tr>
<tr class="separator:a3073aba790f930cb0036209d01c74e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22607aa4670e8d5b16ec3b4055a6f424"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a22607aa4670e8d5b16ec3b4055a6f424">element_type</a> = std::remove_extent_t&lt; T &gt;</td></tr>
<tr class="memdesc:a22607aa4670e8d5b16ec3b4055a6f424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of element managed. <code>T</code> for C++11, and <code>std::remove_extent_t&lt;T&gt;</code> for C++17.  <a href="#a22607aa4670e8d5b16ec3b4055a6f424">More...</a><br /></td></tr>
<tr class="separator:a22607aa4670e8d5b16ec3b4055a6f424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbab334ebfb41a106bb92359b8a2159a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#acbab334ebfb41a106bb92359b8a2159a">weak_type</a> = <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:acbab334ebfb41a106bb92359b8a2159a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of weak pointer from this shared pointer.  <a href="#acbab334ebfb41a106bb92359b8a2159a">More...</a><br /></td></tr>
<tr class="separator:acbab334ebfb41a106bb92359b8a2159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a62318214fc139ad8294ef6e36848413f"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a62318214fc139ad8294ef6e36848413f">SafeSharedPtr</a> ()</td></tr>
<tr class="memdesc:a62318214fc139ad8294ef6e36848413f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, construct a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with no managed object, i.e. empty <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>.  <a href="#a62318214fc139ad8294ef6e36848413f">More...</a><br /></td></tr>
<tr class="separator:a62318214fc139ad8294ef6e36848413f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab35a55267ca0ae27d6fd584609846c6"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#aab35a55267ca0ae27d6fd584609846c6">SafeSharedPtr</a> (std::nullptr_t p)</td></tr>
<tr class="memdesc:aab35a55267ca0ae27d6fd584609846c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with no managed object, i.e. empty <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>.  <a href="#aab35a55267ca0ae27d6fd584609846c6">More...</a><br /></td></tr>
<tr class="separator:aab35a55267ca0ae27d6fd584609846c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212533e3a46e15649ac9105afc9099f9"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a212533e3a46e15649ac9105afc9099f9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a212533e3a46e15649ac9105afc9099f9">SafeSharedPtr</a> (Y *p, typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a212533e3a46e15649ac9105afc9099f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object.  <a href="#a212533e3a46e15649ac9105afc9099f9">More...</a><br /></td></tr>
<tr class="separator:a212533e3a46e15649ac9105afc9099f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58de0adf9393bd19dddf3d6ce2b96e0"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:af58de0adf9393bd19dddf3d6ce2b96e0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#af58de0adf9393bd19dddf3d6ce2b96e0">SafeSharedPtr</a> (Y *p, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:af58de0adf9393bd19dddf3d6ce2b96e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object.  <a href="#af58de0adf9393bd19dddf3d6ce2b96e0">More...</a><br /></td></tr>
<tr class="separator:af58de0adf9393bd19dddf3d6ce2b96e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8111206d7ff77b1b3231f3414a99e2"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename Deleter &gt; </td></tr>
<tr class="memitem:a1e8111206d7ff77b1b3231f3414a99e2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a1e8111206d7ff77b1b3231f3414a99e2">SafeSharedPtr</a> (Y *p, Deleter d, typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a1e8111206d7ff77b1b3231f3414a99e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object of specified deleter.  <a href="#a1e8111206d7ff77b1b3231f3414a99e2">More...</a><br /></td></tr>
<tr class="separator:a1e8111206d7ff77b1b3231f3414a99e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ed2f605d04c95000fd13909f44e90e"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename Deleter &gt; </td></tr>
<tr class="memitem:a20ed2f605d04c95000fd13909f44e90e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a20ed2f605d04c95000fd13909f44e90e">SafeSharedPtr</a> (Y *p, Deleter d, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:a20ed2f605d04c95000fd13909f44e90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object of specified deleter.  <a href="#a20ed2f605d04c95000fd13909f44e90e">More...</a><br /></td></tr>
<tr class="separator:a20ed2f605d04c95000fd13909f44e90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced93a1f713203e8e918bbe0de053563"><td class="memTemplParams" colspan="2">template&lt;typename Deleter &gt; </td></tr>
<tr class="memitem:aced93a1f713203e8e918bbe0de053563"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#aced93a1f713203e8e918bbe0de053563">SafeSharedPtr</a> (std::nullptr_t p, Deleter d)</td></tr>
<tr class="memdesc:aced93a1f713203e8e918bbe0de053563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with with no managed but has specified deleter.  <a href="#aced93a1f713203e8e918bbe0de053563">More...</a><br /></td></tr>
<tr class="separator:aced93a1f713203e8e918bbe0de053563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5de1a37d9b69bed8bf7b098a63aaf1"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename Deleter , typename Alloc &gt; </td></tr>
<tr class="memitem:abd5de1a37d9b69bed8bf7b098a63aaf1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#abd5de1a37d9b69bed8bf7b098a63aaf1">SafeSharedPtr</a> (Y *p, Deleter d, Alloc alloc, typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:abd5de1a37d9b69bed8bf7b098a63aaf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object of specified deleter and allocator.  <a href="#abd5de1a37d9b69bed8bf7b098a63aaf1">More...</a><br /></td></tr>
<tr class="separator:abd5de1a37d9b69bed8bf7b098a63aaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e22d480a18565108ba4c8c1eca23d3e"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename Deleter , typename Alloc &gt; </td></tr>
<tr class="memitem:a1e22d480a18565108ba4c8c1eca23d3e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a1e22d480a18565108ba4c8c1eca23d3e">SafeSharedPtr</a> (Y *p, Deleter d, Alloc alloc, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="separator:a1e22d480a18565108ba4c8c1eca23d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379eceb13c50cc6c7992a740d313be71"><td class="memTemplParams" colspan="2">template&lt;typename Deleter , typename Alloc &gt; </td></tr>
<tr class="memitem:a379eceb13c50cc6c7992a740d313be71"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a379eceb13c50cc6c7992a740d313be71">SafeSharedPtr</a> (std::nullptr_t p, Deleter d, Alloc alloc)</td></tr>
<tr class="memdesc:a379eceb13c50cc6c7992a740d313be71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with no managed but has specified deleter and allocator.  <a href="#a379eceb13c50cc6c7992a740d313be71">More...</a><br /></td></tr>
<tr class="separator:a379eceb13c50cc6c7992a740d313be71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367e171bf3361b48ed95e6270194c230"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename U &gt; </td></tr>
<tr class="memitem:a367e171bf3361b48ed95e6270194c230"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a367e171bf3361b48ed95e6270194c230">SafeSharedPtr</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;other, U *p) noexcept</td></tr>
<tr class="memdesc:a367e171bf3361b48ed95e6270194c230"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aliasing constructor: constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership information with the initial value of <code>other</code>, but holds an unrelated and unmanaged pointer <code>p</code>.  <a href="#a367e171bf3361b48ed95e6270194c230">More...</a><br /></td></tr>
<tr class="separator:a367e171bf3361b48ed95e6270194c230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072e6fb202b3c2997ebbb1077b081c51"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a072e6fb202b3c2997ebbb1077b081c51"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a072e6fb202b3c2997ebbb1077b081c51">SafeSharedPtr</a> (const std::shared_ptr&lt; Y &gt; &amp;other, T *p, typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr) noexcept</td></tr>
<tr class="memdesc:a072e6fb202b3c2997ebbb1077b081c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">The aliasing constructor: constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership information with the initial value of <code>other</code>, but holds an unrelated and unmanaged pointer <code>p</code>.  <a href="#a072e6fb202b3c2997ebbb1077b081c51">More...</a><br /></td></tr>
<tr class="separator:a072e6fb202b3c2997ebbb1077b081c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36edf09caa36c378ba48ea590d44a1c"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ad36edf09caa36c378ba48ea590d44a1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ad36edf09caa36c378ba48ea590d44a1c">SafeSharedPtr</a> (const std::shared_ptr&lt; Y &gt; &amp;other, T *p, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr) noexcept</td></tr>
<tr class="separator:ad36edf09caa36c378ba48ea590d44a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd81e7ac3b7b8df76f1a7a3cb0a0675"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0bd81e7ac3b7b8df76f1a7a3cb0a0675">SafeSharedPtr</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a0bd81e7ac3b7b8df76f1a7a3cb0a0675"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too.  <a href="#a0bd81e7ac3b7b8df76f1a7a3cb0a0675">More...</a><br /></td></tr>
<tr class="separator:a0bd81e7ac3b7b8df76f1a7a3cb0a0675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5395b575b7d4986b4015cf0f40acf521"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a5395b575b7d4986b4015cf0f40acf521"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a5395b575b7d4986b4015cf0f40acf521">SafeSharedPtr</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a5395b575b7d4986b4015cf0f40acf521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too.  <a href="#a5395b575b7d4986b4015cf0f40acf521">More...</a><br /></td></tr>
<tr class="separator:a5395b575b7d4986b4015cf0f40acf521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab132eaebbfed69cdbed2cea9bac5a6fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ab132eaebbfed69cdbed2cea9bac5a6fb">SafeSharedPtr</a> (<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab132eaebbfed69cdbed2cea9bac5a6fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor, move-constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. After the construction, <code>*this</code> contains a copy of the previous state of <code>other</code>, <code>other</code> is empty and its stored pointer is null.  <a href="#ab132eaebbfed69cdbed2cea9bac5a6fb">More...</a><br /></td></tr>
<tr class="separator:ab132eaebbfed69cdbed2cea9bac5a6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edea86a1d2ae32b9c6338845df0d7ff"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a4edea86a1d2ae32b9c6338845df0d7ff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a4edea86a1d2ae32b9c6338845df0d7ff">SafeSharedPtr</a> (<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a4edea86a1d2ae32b9c6338845df0d7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor, move-constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. After the construction, <code>*this</code> contains a copy of the previous state of <code>other</code>, <code>other</code> is empty and its stored pointer is null.  <a href="#a4edea86a1d2ae32b9c6338845df0d7ff">More...</a><br /></td></tr>
<tr class="separator:a4edea86a1d2ae32b9c6338845df0d7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cda9d15e5fd60a5d46cb7d4cee88ca6"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a0cda9d15e5fd60a5d46cb7d4cee88ca6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0cda9d15e5fd60a5d46cb7d4cee88ca6">SafeSharedPtr</a> (const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y &gt; &amp;other)</td></tr>
<tr class="memdesc:a0cda9d15e5fd60a5d46cb7d4cee88ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too.  <a href="#a0cda9d15e5fd60a5d46cb7d4cee88ca6">More...</a><br /></td></tr>
<tr class="separator:a0cda9d15e5fd60a5d46cb7d4cee88ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1ac8e71bc6796e53de60085b8ecf1"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ad6e1ac8e71bc6796e53de60085b8ecf1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ad6e1ac8e71bc6796e53de60085b8ecf1">SafeSharedPtr</a> (const std::shared_ptr&lt; Y &gt; &amp;other, typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:ad6e1ac8e71bc6796e53de60085b8ecf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>, and provide read-write lock guard for memory safety. If <code>other</code> manages no object, <code>*this</code> manages no object too.  <a href="#ad6e1ac8e71bc6796e53de60085b8ecf1">More...</a><br /></td></tr>
<tr class="separator:ad6e1ac8e71bc6796e53de60085b8ecf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc15db659b2b872ed46477cfc3d1332f"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:acc15db659b2b872ed46477cfc3d1332f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#acc15db659b2b872ed46477cfc3d1332f">SafeSharedPtr</a> (const std::shared_ptr&lt; Y &gt; &amp;other, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="separator:acc15db659b2b872ed46477cfc3d1332f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ba6ee332573200c08414d767f9dc8f"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ae9ba6ee332573200c08414d767f9dc8f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae9ba6ee332573200c08414d767f9dc8f">SafeSharedPtr</a> (std::shared_ptr&lt; Y &gt; &amp;&amp;other, typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="memdesc:ae9ba6ee332573200c08414d767f9dc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. After the construction, <code>*this</code> contains a copy of the previous state of <code>other</code>, <code>other</code> is empty and its stored pointer is null.  <a href="#ae9ba6ee332573200c08414d767f9dc8f">More...</a><br /></td></tr>
<tr class="separator:ae9ba6ee332573200c08414d767f9dc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958664e996699c404b7e5f0c213af58c"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a958664e996699c404b7e5f0c213af58c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a958664e996699c404b7e5f0c213af58c">SafeSharedPtr</a> (std::shared_ptr&lt; Y &gt; &amp;&amp;other, typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *=nullptr)</td></tr>
<tr class="separator:a958664e996699c404b7e5f0c213af58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6591b6b5ddc20621a5640916c5a0aafb"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a6591b6b5ddc20621a5640916c5a0aafb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a6591b6b5ddc20621a5640916c5a0aafb">SafeSharedPtr</a> (const std::weak_ptr&lt; Y &gt; &amp;other)</td></tr>
<tr class="memdesc:a6591b6b5ddc20621a5640916c5a0aafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. and provide read-write lock guard for memory safety. If <code>other</code> manages no object, <code>*this</code> manages no object too.  <a href="#a6591b6b5ddc20621a5640916c5a0aafb">More...</a><br /></td></tr>
<tr class="separator:a6591b6b5ddc20621a5640916c5a0aafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7382cdc4495e3a92acbe7dbde40a70c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#aa7382cdc4495e3a92acbe7dbde40a70c">~SafeSharedPtr</a> ()=default</td></tr>
<tr class="memdesc:aa7382cdc4495e3a92acbe7dbde40a70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, destructs the owned object if no more <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> link to it.  <a href="#aa7382cdc4495e3a92acbe7dbde40a70c">More...</a><br /></td></tr>
<tr class="separator:aa7382cdc4495e3a92acbe7dbde40a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fd5594f4062ed48ad5a03df76ebf96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a38fd5594f4062ed48ad5a03df76ebf96">operator=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a38fd5594f4062ed48ad5a03df76ebf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares ownership of the object managed by <code>other</code>.  <a href="#a38fd5594f4062ed48ad5a03df76ebf96">More...</a><br /></td></tr>
<tr class="separator:a38fd5594f4062ed48ad5a03df76ebf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496e77475a80eae8f017252228b3a64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a496e77475a80eae8f017252228b3a64f">operator=</a> (<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a496e77475a80eae8f017252228b3a64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>.  <a href="#a496e77475a80eae8f017252228b3a64f">More...</a><br /></td></tr>
<tr class="separator:a496e77475a80eae8f017252228b3a64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bf58f3bb1d7220bf5f52c7cd65a721"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ac7bf58f3bb1d7220bf5f52c7cd65a721"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ac7bf58f3bb1d7220bf5f52c7cd65a721">operator=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:ac7bf58f3bb1d7220bf5f52c7cd65a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares ownership of the object managed by <code>other</code>.  <a href="#ac7bf58f3bb1d7220bf5f52c7cd65a721">More...</a><br /></td></tr>
<tr class="separator:ac7bf58f3bb1d7220bf5f52c7cd65a721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab585d0ffe2278eb35e865a9cfa103877"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ab585d0ffe2278eb35e865a9cfa103877"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ab585d0ffe2278eb35e865a9cfa103877">operator=</a> (<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab585d0ffe2278eb35e865a9cfa103877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>.  <a href="#ab585d0ffe2278eb35e865a9cfa103877">More...</a><br /></td></tr>
<tr class="separator:ab585d0ffe2278eb35e865a9cfa103877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a926e8afddb5a17f1bef75fc80a7cfb"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a5a926e8afddb5a17f1bef75fc80a7cfb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a5a926e8afddb5a17f1bef75fc80a7cfb">operator=</a> (const std::shared_ptr&lt; Y &gt; &amp;other)</td></tr>
<tr class="memdesc:a5a926e8afddb5a17f1bef75fc80a7cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shares ownership of the object managed by <code>other</code>, and provide read-write lock guard for memory safety.  <a href="#a5a926e8afddb5a17f1bef75fc80a7cfb">More...</a><br /></td></tr>
<tr class="separator:a5a926e8afddb5a17f1bef75fc80a7cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944ac1ce9d6c0e192137da2a9aef0851"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a944ac1ce9d6c0e192137da2a9aef0851"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a944ac1ce9d6c0e192137da2a9aef0851">operator=</a> (std::shared_ptr&lt; Y &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a944ac1ce9d6c0e192137da2a9aef0851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>, provide read-write lock guard for memory safety.  <a href="#a944ac1ce9d6c0e192137da2a9aef0851">More...</a><br /></td></tr>
<tr class="separator:a944ac1ce9d6c0e192137da2a9aef0851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04ef16994300ab38b8890f617780428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428">reset</a> ()</td></tr>
<tr class="memdesc:ae04ef16994300ab38b8890f617780428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership of the managed object, if any. After the call, <code>*this</code> manages no object.  <a href="#ae04ef16994300ab38b8890f617780428">More...</a><br /></td></tr>
<tr class="separator:ae04ef16994300ab38b8890f617780428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae887a60a677dd18f1c971312a3c8c2f5"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ae887a60a677dd18f1c971312a3c8c2f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae887a60a677dd18f1c971312a3c8c2f5">reset</a> (Y *ptr)</td></tr>
<tr class="memdesc:ae887a60a677dd18f1c971312a3c8c2f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr. Uses the delete expression as the deleter.  <a href="#ae887a60a677dd18f1c971312a3c8c2f5">More...</a><br /></td></tr>
<tr class="separator:ae887a60a677dd18f1c971312a3c8c2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23bf67de01d20722d835dc9f92628b7"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename Deleter &gt; </td></tr>
<tr class="memitem:ae23bf67de01d20722d835dc9f92628b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae23bf67de01d20722d835dc9f92628b7">reset</a> (Y *ptr, Deleter d)</td></tr>
<tr class="memdesc:ae23bf67de01d20722d835dc9f92628b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr. Uses the specified deleter <code>d</code> as the deleter.  <a href="#ae23bf67de01d20722d835dc9f92628b7">More...</a><br /></td></tr>
<tr class="separator:ae23bf67de01d20722d835dc9f92628b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c509c7adb21d071492179e5e018436c"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename Deleter , typename Alloc &gt; </td></tr>
<tr class="memitem:a8c509c7adb21d071492179e5e018436c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8c509c7adb21d071492179e5e018436c">reset</a> (Y *ptr, Deleter d, Alloc alloc)</td></tr>
<tr class="memdesc:a8c509c7adb21d071492179e5e018436c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the managed object with an object pointed to by ptr. Uses the specified deleter <code>d</code> as the deleter. Uses a copy of alloc for allocation of data for internal use.  <a href="#a8c509c7adb21d071492179e5e018436c">More...</a><br /></td></tr>
<tr class="separator:a8c509c7adb21d071492179e5e018436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffa1031dbd8a12bc24b846f4d374be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#aaffa1031dbd8a12bc24b846f4d374be3">swap</a> (<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:aaffa1031dbd8a12bc24b846f4d374be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the contents of <code>*this</code> and <code>other</code>.  <a href="#aaffa1031dbd8a12bc24b846f4d374be3">More...</a><br /></td></tr>
<tr class="separator:aaffa1031dbd8a12bc24b846f4d374be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8200a5e400aeacdfba8254c56ecf26a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a22607aa4670e8d5b16ec3b4055a6f424">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3">get</a> () const noexcept</td></tr>
<tr class="memdesc:a8200a5e400aeacdfba8254c56ecf26a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the stored pointer.  <a href="#a8200a5e400aeacdfba8254c56ecf26a3">More...</a><br /></td></tr>
<tr class="separator:a8200a5e400aeacdfba8254c56ecf26a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9eb632586e9ecd46df445ae1acc081"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ref_helper.html">RefHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0d9eb632586e9ecd46df445ae1acc081">operator *</a> () noexcept</td></tr>
<tr class="memdesc:a0d9eb632586e9ecd46df445ae1acc081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer, guard it with <b>write lock</b>. The behavior is undefined if the stored pointer is null.  <a href="#a0d9eb632586e9ecd46df445ae1acc081">More...</a><br /></td></tr>
<tr class="separator:a0d9eb632586e9ecd46df445ae1acc081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b2673f6dd4ea6a8ea8d1e6a78d587"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ref_helper.html">RefHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ad63b2673f6dd4ea6a8ea8d1e6a78d587">operator *</a> () const noexcept</td></tr>
<tr class="memdesc:ad63b2673f6dd4ea6a8ea8d1e6a78d587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer, guard it with <b>read lock</b>. The behavior is undefined if the stored pointer is null.  <a href="#ad63b2673f6dd4ea6a8ea8d1e6a78d587">More...</a><br /></td></tr>
<tr class="separator:ad63b2673f6dd4ea6a8ea8d1e6a78d587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279d36432aa9b9a9875a45a1dcbbd158"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ptr_helper.html">PtrHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a279d36432aa9b9a9875a45a1dcbbd158">operator-&gt;</a> () noexcept</td></tr>
<tr class="memdesc:a279d36432aa9b9a9875a45a1dcbbd158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer, guard it with <b>write lock</b>. The behavior is undefined if the stored pointer is null.  <a href="#a279d36432aa9b9a9875a45a1dcbbd158">More...</a><br /></td></tr>
<tr class="separator:a279d36432aa9b9a9875a45a1dcbbd158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c50f396e82c71677d138aaa535129b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ptr_helper.html">PtrHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a28c50f396e82c71677d138aaa535129b">operator-&gt;</a> () const noexcept</td></tr>
<tr class="memdesc:a28c50f396e82c71677d138aaa535129b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the stored pointer, guard it with <b>read lock</b>. The behavior is undefined if the stored pointer is null.  <a href="#a28c50f396e82c71677d138aaa535129b">More...</a><br /></td></tr>
<tr class="separator:a28c50f396e82c71677d138aaa535129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b904d3fde170a4984aa5668009c7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_array_helper.html">ArrayHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ab1b904d3fde170a4984aa5668009c7fd">operator[]</a> (std::ptrdiff_t idx)</td></tr>
<tr class="memdesc:ab1b904d3fde170a4984aa5668009c7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides indexed access to the stored array, guard it with <b>write lock</b>.  <a href="#ab1b904d3fde170a4984aa5668009c7fd">More...</a><br /></td></tr>
<tr class="separator:ab1b904d3fde170a4984aa5668009c7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea86c8dcc5ad23decbddc4cf0fa3772"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_array_helper.html">ArrayHelper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a5ea86c8dcc5ad23decbddc4cf0fa3772">operator[]</a> (std::ptrdiff_t idx) const</td></tr>
<tr class="memdesc:a5ea86c8dcc5ad23decbddc4cf0fa3772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides indexed access to the stored array, guard it with <b>read lock</b>.  <a href="#a5ea86c8dcc5ad23decbddc4cf0fa3772">More...</a><br /></td></tr>
<tr class="separator:a5ea86c8dcc5ad23decbddc4cf0fa3772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0193148c36b6146d578eda25f501995"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#aa0193148c36b6146d578eda25f501995">use_count</a> () const noexcept</td></tr>
<tr class="memdesc:aa0193148c36b6146d578eda25f501995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> objects referring to the same managed object.  <a href="#aa0193148c36b6146d578eda25f501995">More...</a><br /></td></tr>
<tr class="separator:aa0193148c36b6146d578eda25f501995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f3d84c401dc5458ddb7b2409ab1a95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ab4f3d84c401dc5458ddb7b2409ab1a95">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ab4f3d84c401dc5458ddb7b2409ab1a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if *this stores a non-null pointer, i.e. whether <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> != nullptr</code>.  <a href="#ab4f3d84c401dc5458ddb7b2409ab1a95">More...</a><br /></td></tr>
<tr class="separator:ab4f3d84c401dc5458ddb7b2409ab1a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bcc785c0d40055626647380c03c5be"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a13bcc785c0d40055626647380c03c5be"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a13bcc785c0d40055626647380c03c5be">owner_before</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;other) const</td></tr>
<tr class="memdesc:a13bcc785c0d40055626647380c03c5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#a13bcc785c0d40055626647380c03c5be">More...</a><br /></td></tr>
<tr class="separator:a13bcc785c0d40055626647380c03c5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c5707b80a33b6dd4c27cb828aa7e7f"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a31c5707b80a33b6dd4c27cb828aa7e7f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a31c5707b80a33b6dd4c27cb828aa7e7f">owner_before</a> (const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y &gt; &amp;other) const</td></tr>
<tr class="memdesc:a31c5707b80a33b6dd4c27cb828aa7e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> precedes other in implementation defined owner-based (as opposed to value-based) order.  <a href="#a31c5707b80a33b6dd4c27cb828aa7e7f">More...</a><br /></td></tr>
<tr class="separator:a31c5707b80a33b6dd4c27cb828aa7e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9054feae00b20d15e00879a49e683d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69">lock_shared</a> () const</td></tr>
<tr class="memdesc:a9054feae00b20d15e00879a49e683d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the lock for reading. This function will block the current thread if another thread has locked for writing.  <a href="#a9054feae00b20d15e00879a49e683d69">More...</a><br /></td></tr>
<tr class="separator:a9054feae00b20d15e00879a49e683d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae148778e9c3ac646541964ad048538b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2">unlock_shared</a> () const</td></tr>
<tr class="memdesc:ae148778e9c3ac646541964ad048538b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the read lock.  <a href="#ae148778e9c3ac646541964ad048538b2">More...</a><br /></td></tr>
<tr class="separator:ae148778e9c3ac646541964ad048538b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489e2c856bdae027f8a9f58c9b012f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3">lock</a> ()</td></tr>
<tr class="memdesc:a0489e2c856bdae027f8a9f58c9b012f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the lock for writing. This function will block the current thread if another thread (including the current) has locked for reading or writing.  <a href="#a0489e2c856bdae027f8a9f58c9b012f3">More...</a><br /></td></tr>
<tr class="separator:a0489e2c856bdae027f8a9f58c9b012f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8ba57f44e791d30ee35b9b7e368a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b">unlock</a> () const</td></tr>
<tr class="memdesc:a2e8ba57f44e791d30ee35b9b7e368a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the write lock.  <a href="#a2e8ba57f44e791d30ee35b9b7e368a3b">More...</a><br /></td></tr>
<tr class="separator:a2e8ba57f44e791d30ee35b9b7e368a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f12fe979b880a62a790a4111d456d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a94dd72f327e72c8aff63ab8a97b0895e">SharedLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a14f12fe979b880a62a790a4111d456d6">shared_lock</a> () const</td></tr>
<tr class="memdesc:a14f12fe979b880a62a790a4111d456d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a RAII guard for read lock, it will call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> on destruction.  <a href="#a14f12fe979b880a62a790a4111d456d6">More...</a><br /></td></tr>
<tr class="separator:a14f12fe979b880a62a790a4111d456d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b16495f58c9d1c30f2a14d54d5a98c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a3073aba790f930cb0036209d01c74e52">UniqueLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a49b16495f58c9d1c30f2a14d54d5a98c">unique_lock</a> () const</td></tr>
<tr class="memdesc:a49b16495f58c9d1c30f2a14d54d5a98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a RAII guard for write lock, it will call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> on destruction.  <a href="#a49b16495f58c9d1c30f2a14d54d5a98c">More...</a><br /></td></tr>
<tr class="separator:a49b16495f58c9d1c30f2a14d54d5a98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ac2f2567609b6d0f0fa7e001f08497d0e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ac2f2567609b6d0f0fa7e001f08497d0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ac2f2567609b6d0f0fa7e001f08497d0e">make_shared</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ac2f2567609b6d0f0fa7e001f08497d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer that manages a new object.  <a href="#ac2f2567609b6d0f0fa7e001f08497d0e">More...</a><br /></td></tr>
<tr class="separator:ac2f2567609b6d0f0fa7e001f08497d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b0281caedef04ec18b523c389f3c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc , typename... Args&gt; </td></tr>
<tr class="memitem:a185b0281caedef04ec18b523c389f3c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a185b0281caedef04ec18b523c389f3c3">allocate_shared</a> (const Alloc &amp;alloc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a185b0281caedef04ec18b523c389f3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a shared pointer that manages a new object allocated using an allocator.  <a href="#a185b0281caedef04ec18b523c389f3c3">More...</a><br /></td></tr>
<tr class="separator:a185b0281caedef04ec18b523c389f3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dea18ba7a29f4a2760beee3279ab567"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a4dea18ba7a29f4a2760beee3279ab567"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a4dea18ba7a29f4a2760beee3279ab567">static_pointer_cast</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;r) noexcept</td></tr>
<tr class="memdesc:a4dea18ba7a29f4a2760beee3279ab567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies static_cast to the stored pointer.  <a href="#a4dea18ba7a29f4a2760beee3279ab567">More...</a><br /></td></tr>
<tr class="separator:a4dea18ba7a29f4a2760beee3279ab567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1118482869ccf73f0a83d2e5cf976c68"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a1118482869ccf73f0a83d2e5cf976c68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a1118482869ccf73f0a83d2e5cf976c68">dynamic_pointer_cast</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;r) noexcept</td></tr>
<tr class="memdesc:a1118482869ccf73f0a83d2e5cf976c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies dynamic_cast to the stored pointer.  <a href="#a1118482869ccf73f0a83d2e5cf976c68">More...</a><br /></td></tr>
<tr class="separator:a1118482869ccf73f0a83d2e5cf976c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856963fe8204761ebecfebdcc793c041"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a856963fe8204761ebecfebdcc793c041"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a856963fe8204761ebecfebdcc793c041">const_pointer_cast</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;r) noexcept</td></tr>
<tr class="memdesc:a856963fe8204761ebecfebdcc793c041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies const_cast to the stored pointer.  <a href="#a856963fe8204761ebecfebdcc793c041">More...</a><br /></td></tr>
<tr class="separator:a856963fe8204761ebecfebdcc793c041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dfd0c539b8114ba4a245b9d678172d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a29dfd0c539b8114ba4a245b9d678172d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a29dfd0c539b8114ba4a245b9d678172d">reinterpret_pointer_cast</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;r) noexcept</td></tr>
<tr class="memdesc:a29dfd0c539b8114ba4a245b9d678172d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies reinterpret_cast to the stored pointer.  <a href="#a29dfd0c539b8114ba4a245b9d678172d">More...</a><br /></td></tr>
<tr class="separator:a29dfd0c539b8114ba4a245b9d678172d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace42ca49c33d5133308a117c1c6ad2b5"><td class="memTemplParams" colspan="2">template&lt;typename Deleter , typename T &gt; </td></tr>
<tr class="memitem:ace42ca49c33d5133308a117c1c6ad2b5"><td class="memTemplItemLeft" align="right" valign="top">Deleter *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ace42ca49c33d5133308a117c1c6ad2b5">get_deleter</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;p) noexcept</td></tr>
<tr class="memdesc:ace42ca49c33d5133308a117c1c6ad2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the deleter of specified type, if owned.  <a href="#ace42ca49c33d5133308a117c1c6ad2b5">More...</a><br /></td></tr>
<tr class="separator:ace42ca49c33d5133308a117c1c6ad2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53e07f9f4e07d2d8b4a1a5d85cb3b47"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac53e07f9f4e07d2d8b4a1a5d85cb3b47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ac53e07f9f4e07d2d8b4a1a5d85cb3b47">operator==</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ac53e07f9f4e07d2d8b4a1a5d85cb3b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#ac53e07f9f4e07d2d8b4a1a5d85cb3b47">More...</a><br /></td></tr>
<tr class="separator:ac53e07f9f4e07d2d8b4a1a5d85cb3b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0747db920a97bbfc4b8f8e6b087126d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:af0747db920a97bbfc4b8f8e6b087126d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#af0747db920a97bbfc4b8f8e6b087126d">operator!=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:af0747db920a97bbfc4b8f8e6b087126d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#af0747db920a97bbfc4b8f8e6b087126d">More...</a><br /></td></tr>
<tr class="separator:af0747db920a97bbfc4b8f8e6b087126d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c09d70ee247aec26a126ccbc655c20d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a0c09d70ee247aec26a126ccbc655c20d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0c09d70ee247aec26a126ccbc655c20d">operator&lt;</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a0c09d70ee247aec26a126ccbc655c20d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a0c09d70ee247aec26a126ccbc655c20d">More...</a><br /></td></tr>
<tr class="separator:a0c09d70ee247aec26a126ccbc655c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8f1945aca212b8d5ea827d4a2a3e4a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a6b8f1945aca212b8d5ea827d4a2a3e4a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a6b8f1945aca212b8d5ea827d4a2a3e4a">operator&gt;</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a6b8f1945aca212b8d5ea827d4a2a3e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a6b8f1945aca212b8d5ea827d4a2a3e4a">More...</a><br /></td></tr>
<tr class="separator:a6b8f1945aca212b8d5ea827d4a2a3e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b89a5b6a71ad2e674074ad679c073b5"><td class="memTemplParams" colspan="2">template&lt;typename T , class U &gt; </td></tr>
<tr class="memitem:a5b89a5b6a71ad2e674074ad679c073b5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a5b89a5b6a71ad2e674074ad679c073b5">operator&lt;=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a5b89a5b6a71ad2e674074ad679c073b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a5b89a5b6a71ad2e674074ad679c073b5">More...</a><br /></td></tr>
<tr class="separator:a5b89a5b6a71ad2e674074ad679c073b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c1fe1f0b57138c0e5081406056d348"><td class="memTemplParams" colspan="2">template&lt;typename T , class U &gt; </td></tr>
<tr class="memitem:a87c1fe1f0b57138c0e5081406056d348"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a87c1fe1f0b57138c0e5081406056d348">operator&gt;=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a87c1fe1f0b57138c0e5081406056d348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a87c1fe1f0b57138c0e5081406056d348">More...</a><br /></td></tr>
<tr class="separator:a87c1fe1f0b57138c0e5081406056d348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61aa5232247537b3f4a3763477a2f642"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61aa5232247537b3f4a3763477a2f642"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a61aa5232247537b3f4a3763477a2f642">operator==</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) noexcept</td></tr>
<tr class="memdesc:a61aa5232247537b3f4a3763477a2f642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a61aa5232247537b3f4a3763477a2f642">More...</a><br /></td></tr>
<tr class="separator:a61aa5232247537b3f4a3763477a2f642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db5c3b0da8cae814f43c085bdf2b61"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02db5c3b0da8cae814f43c085bdf2b61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a02db5c3b0da8cae814f43c085bdf2b61">operator==</a> (std::nullptr_t lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a02db5c3b0da8cae814f43c085bdf2b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a02db5c3b0da8cae814f43c085bdf2b61">More...</a><br /></td></tr>
<tr class="separator:a02db5c3b0da8cae814f43c085bdf2b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20be7a051613d73357f1f37567584af5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20be7a051613d73357f1f37567584af5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a20be7a051613d73357f1f37567584af5">operator!=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) noexcept</td></tr>
<tr class="memdesc:a20be7a051613d73357f1f37567584af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a20be7a051613d73357f1f37567584af5">More...</a><br /></td></tr>
<tr class="separator:a20be7a051613d73357f1f37567584af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ab50448af1b179793f7be4c716c65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a028ab50448af1b179793f7be4c716c65"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a028ab50448af1b179793f7be4c716c65">operator!=</a> (std::nullptr_t lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a028ab50448af1b179793f7be4c716c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a028ab50448af1b179793f7be4c716c65">More...</a><br /></td></tr>
<tr class="separator:a028ab50448af1b179793f7be4c716c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093326c04024e5295700ff8267a04059"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a093326c04024e5295700ff8267a04059"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a093326c04024e5295700ff8267a04059">operator&lt;</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) noexcept</td></tr>
<tr class="memdesc:a093326c04024e5295700ff8267a04059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a093326c04024e5295700ff8267a04059">More...</a><br /></td></tr>
<tr class="separator:a093326c04024e5295700ff8267a04059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ffa000eef3fb8d7125477cfdf6f7bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2ffa000eef3fb8d7125477cfdf6f7bc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ad2ffa000eef3fb8d7125477cfdf6f7bc">operator&lt;</a> (std::nullptr_t lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:ad2ffa000eef3fb8d7125477cfdf6f7bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#ad2ffa000eef3fb8d7125477cfdf6f7bc">More...</a><br /></td></tr>
<tr class="separator:ad2ffa000eef3fb8d7125477cfdf6f7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b767d7f500c119edcea607cd9ecf363"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b767d7f500c119edcea607cd9ecf363"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a6b767d7f500c119edcea607cd9ecf363">operator&gt;</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) noexcept</td></tr>
<tr class="memdesc:a6b767d7f500c119edcea607cd9ecf363"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a6b767d7f500c119edcea607cd9ecf363">More...</a><br /></td></tr>
<tr class="separator:a6b767d7f500c119edcea607cd9ecf363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6b9da0ab3e08ba6699dbccbf4ad023"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc6b9da0ab3e08ba6699dbccbf4ad023"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#afc6b9da0ab3e08ba6699dbccbf4ad023">operator&gt;</a> (std::nullptr_t lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:afc6b9da0ab3e08ba6699dbccbf4ad023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#afc6b9da0ab3e08ba6699dbccbf4ad023">More...</a><br /></td></tr>
<tr class="separator:afc6b9da0ab3e08ba6699dbccbf4ad023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084be4724427c94b607c083cfa5f7063"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a084be4724427c94b607c083cfa5f7063"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a084be4724427c94b607c083cfa5f7063">operator&lt;=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) noexcept</td></tr>
<tr class="memdesc:a084be4724427c94b607c083cfa5f7063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a084be4724427c94b607c083cfa5f7063">More...</a><br /></td></tr>
<tr class="separator:a084be4724427c94b607c083cfa5f7063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4f2db5890e76370f2d64ab459d8f0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7c4f2db5890e76370f2d64ab459d8f0b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a7c4f2db5890e76370f2d64ab459d8f0b">operator&lt;=</a> (std::nullptr_t lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a7c4f2db5890e76370f2d64ab459d8f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a7c4f2db5890e76370f2d64ab459d8f0b">More...</a><br /></td></tr>
<tr class="separator:a7c4f2db5890e76370f2d64ab459d8f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0623042e9db311b02dee5937dca19998"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0623042e9db311b02dee5937dca19998"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0623042e9db311b02dee5937dca19998">operator&gt;=</a> (const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;lhs, std::nullptr_t rhs) noexcept</td></tr>
<tr class="memdesc:a0623042e9db311b02dee5937dca19998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a0623042e9db311b02dee5937dca19998">More...</a><br /></td></tr>
<tr class="separator:a0623042e9db311b02dee5937dca19998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d9c37e45238556d318d32bcd6c4e45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64d9c37e45238556d318d32bcd6c4e45"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a64d9c37e45238556d318d32bcd6c4e45">operator&gt;=</a> (std::nullptr_t lhs, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a64d9c37e45238556d318d32bcd6c4e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input.  <a href="#a64d9c37e45238556d318d32bcd6c4e45">More...</a><br /></td></tr>
<tr class="separator:a64d9c37e45238556d318d32bcd6c4e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4faa671666b25d861a5ef54ac1ab6eba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename V &gt; </td></tr>
<tr class="memitem:a4faa671666b25d861a5ef54ac1ab6eba"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a4faa671666b25d861a5ef54ac1ab6eba">operator&lt;&lt;</a> (std::basic_ostream&lt; U, V &gt; &amp;os, const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a4faa671666b25d861a5ef54ac1ab6eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs the value of the stored pointer to an output stream.  <a href="#a4faa671666b25d861a5ef54ac1ab6eba">More...</a><br /></td></tr>
<tr class="separator:a4faa671666b25d861a5ef54ac1ab6eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4444a22b9071062486cbc47d26a114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d4444a22b9071062486cbc47d26a114"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a3d4444a22b9071062486cbc47d26a114">swap</a> (<a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt; &amp;lhs, <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3d4444a22b9071062486cbc47d26a114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specializes the <code>std::swap</code> algorithm.  <a href="#a3d4444a22b9071062486cbc47d26a114">More...</a><br /></td></tr>
<tr class="separator:a3d4444a22b9071062486cbc47d26a114"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class Memory::SafeSharedPtr&lt; T &gt;</h3>

<p>Wrapper to <code>std::shared_ptr</code> to provide thread-safety while operating the underlying pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object managed by <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Same API as <code>std::shared_ptr</code>, but operator* and operator() are guarded by read-write lock to guarantee thread-safety.<br />
 When <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> is a constant object, operations with underlying pointer will be guarded by read lock.<br />
 When <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> is a mutable object, operations with underlying pointer will be guarded by write lock.<br />
 <br />
 <b>Sample Code</b><br />
</p><div class="fragment"><div class="line"><a class="code" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr&lt;int&gt;</a> ptr = make_shared&lt;int&gt;(0);</div><div class="line">std::thread thread[](<a class="code" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr&lt;int&gt;</a> ptr){</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000 * 1000; ++i)</div><div class="line">        +ptr += 1;</div><div class="line">}, ptr);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000 * 1000; ++i)</div><div class="line">    *ptr += 1;</div><div class="line">thread.join();</div><div class="line">std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 2000000</span></div></div><!-- fragment --><p> To prevent lock/unlock too often, call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> / <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a>, then use <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> for raw pointer directly, call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> / <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> when finished.<br />
 <br />
 See <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr">https://en.cppreference.com/w/cpp/memory/shared_ptr</a> for more details of functionalities with std::shared_ptr.<br />
 </p><hr/>
<p><b>Benchmark on (Intel(R) Core(R) CPU i5-6300U @ 2.4GHz Turbo 2.9GHz) 2 cores(4 HTs)</b></p>
<p>Contention Benchmark on integer plus, 90% read, 10% write.</p>
<table class="doxtable">
<tr>
<th>Data Type</th><th>Threads</th><th>Iters </th><th>Total t</th><th>t/iter</th><th>iter/sec  </th></tr>
<tr>
<th colspan="6">MinGW 4.8.2 32bit on C++11 with <a class="el" href="class_memory_1_1_r_w_spin_lock.html" title="High-performance read-write-spinlock, see RWSpinLock.hpp for details.">RWSpinLock</a>  </th></tr>
<tr>
<td>int*</td><td>1</td><td>1,000,000 </td><td>1.59 ms</td><td>1.59 ns</td><td>627 M  </td></tr>
<tr>
<td><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></td><td>1</td><td>1,000,000 </td><td>17.62 ms</td><td>17.62 ns</td><td>56.73 M  </td></tr>
<tr>
<td><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></td><td>4</td><td>1,000,000 </td><td>251.4 ms</td><td>62.85 ns</td><td>15.91 M  </td></tr>
<tr>
<td><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></td><td>8</td><td>1,000,000 </td><td>720.57 ms</td><td>90.07 ns</td><td>11.1 M  </td></tr>
<tr>
<th colspan="6">MSVC 2017 64bit (cl 19.16.27024.1) on C++17 with std::shared_mutex  </th></tr>
<tr>
<td>int*</td><td>1</td><td>1,000,000 </td><td>1.61 ms</td><td>1.6 ns</td><td>620.96 M  </td></tr>
<tr>
<td><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></td><td>1</td><td>1,000,000 </td><td>17.08 ms</td><td>17.08 ns</td><td>58.57 M  </td></tr>
<tr>
<td><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></td><td>4</td><td>1,000,000 </td><td>80.81 ms</td><td>20.2 ns</td><td>49.5 M  </td></tr>
<tr>
<td><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></td><td>8</td><td>1,000,000 </td><td>159.16 ms</td><td>19.9 ns</td><td>50.26 M  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd><b>Before C++17</b>, for the purposes of the description below, a pointer type <code>Y*</code> requires that <code>Y*</code> must be implicitly convertible to <code>T*</code>.<br />
 <b>Since C++17</b>, for the purposes of the description below, a pointer type <code>Y*</code> is said to be <b>compatible</b> with a pointer type <code>T*</code> if either <code>Y*</code> is convertible to <code>T*</code> or <code>Y</code> is the array type <code>U[N]</code> and <code>T</code> is <code>U cv []</code> (where cv is some set of cv-qualifiers).<br />
 <b>Since C++17</b>, default deleter called on destructor will use <code>delete[]</code> if <code>T</code> is an arry type; </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Read-write lock used in this class is <b>NOT</b> recursive, so <b>DO NOT</b> call <code>operator.</code> <code>operator-&gt;</code> or <code>operator[]</code> multiply times in a single line/expression, otherwise a <b>deadlock</b> will happen. Sorry for the inconvenience. <div class="fragment"><div class="line"><span class="comment">// deadlock happens</span></div><div class="line">std::cout &lt;&lt; point-&gt;x() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; point-&gt;y() &lt;&lt; std::endl;</div></div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a>, <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html" title="A proxy class from std::enable_shared_from_this to provide same functionality for SafeSharedPtr.">EnableSafeSharedFromThis</a> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afee9452fe9852f8e57a86cf8f3124b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee9452fe9852f8e57a86cf8f3124b89">&#9670;&nbsp;</a></span>ReadWriteLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html#afee9452fe9852f8e57a86cf8f3124b89">ReadWriteLock</a> =  std::shared_mutex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined to <code>std::shared_mutex</code> with C++17 or higher, otherwise defined to <a class="el" href="class_memory_1_1_r_w_spin_lock.html" title="High-performance read-write-spinlock, see RWSpinLock.hpp for details.">RWSpinLock</a>. </p>

</div>
</div>
<a id="a94dd72f327e72c8aff63ab8a97b0895e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94dd72f327e72c8aff63ab8a97b0895e">&#9670;&nbsp;</a></span>SharedLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html#a94dd72f327e72c8aff63ab8a97b0895e">SharedLock</a> =  std::shared_lock&lt;std::shared_mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined to <code>std::shared_lock&lt;std::shared_mutex&gt;</code> with C++17 or higher, otherwise defined to <a class="el" href="class_memory_1_1_r_w_spin_lock_1_1_read_holder.html" title="RAII guard for read lock with RWSpinLock::lock_shared() on construction and RWSpinLock::unlock_shared...">RWSpinLock::ReadHolder</a>. </p>

</div>
</div>
<a id="a3073aba790f930cb0036209d01c74e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3073aba790f930cb0036209d01c74e52">&#9670;&nbsp;</a></span>UniqueLock</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html#a3073aba790f930cb0036209d01c74e52">UniqueLock</a> =  std::unique_lock&lt;std::shared_mutex&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defined to <code>std::unique_lock&lt;std::shared_mutex&gt;</code> with C++17 or higher, otherwise defined to <a class="el" href="class_memory_1_1_r_w_spin_lock_1_1_write_holder.html" title="RAII guard for write lock with RWSpinLock::lock() on construction and RWSpinLock::unlock() on destruc...">RWSpinLock::WriteHolder</a>. </p>

</div>
</div>
<a id="a22607aa4670e8d5b16ec3b4055a6f424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22607aa4670e8d5b16ec3b4055a6f424">&#9670;&nbsp;</a></span>element_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html#a22607aa4670e8d5b16ec3b4055a6f424">element_type</a> =  std::remove_extent_t&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of element managed. <code>T</code> for C++11, and <code>std::remove_extent_t&lt;T&gt;</code> for C++17. </p>

</div>
</div>
<a id="acbab334ebfb41a106bb92359b8a2159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbab334ebfb41a106bb92359b8a2159a">&#9670;&nbsp;</a></span>weak_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html#acbab334ebfb41a106bb92359b8a2159a">weak_type</a> =  <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of weak pointer from this shared pointer. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a62318214fc139ad8294ef6e36848413f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62318214fc139ad8294ef6e36848413f">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[1/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, construct a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with no managed object, i.e. empty <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab35a55267ca0ae27d6fd584609846c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab35a55267ca0ae27d6fd584609846c6">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[2/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with no managed object, i.e. empty <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a212533e3a46e15649ac9105afc9099f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212533e3a46e15649ac9105afc9099f9">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[3/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to an object to manage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. <code>delete p</code> (if T is not an array type, <code>delete[] p</code> otherwise) (since C++17) is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af58de0adf9393bd19dddf3d6ce2b96e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58de0adf9393bd19dddf3d6ce2b96e0">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[4/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to an object to manage. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. <code>delete p</code> (if T is not an array type, <code>delete[] p</code> otherwise) (since C++17) is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e8111206d7ff77b1b3231f3414a99e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8111206d7ff77b1b3231f3414a99e2">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[5/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object of specified deleter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to an object to manage. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to use to destroy the object, must be <code>CopyConstructible</code>, and expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. d(p) is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20ed2f605d04c95000fd13909f44e90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ed2f605d04c95000fd13909f44e90e">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[6/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object of specified deleter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to an object to manage. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to use to destroy the object, must be <code>CopyConstructible</code>, and expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. d(p) is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aced93a1f713203e8e918bbe0de053563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced93a1f713203e8e918bbe0de053563">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[7/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with with no managed but has specified deleter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>nullptr. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to use to destroy the object, must be <code>CopyConstructible</code>, and expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. d(p) is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd5de1a37d9b69bed8bf7b098a63aaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5de1a37d9b69bed8bf7b098a63aaf1">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[8/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename Deleter , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with a managed object of specified deleter and allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of specified allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to an object to manage. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to use to destroy the object, must be <code>CopyConstructible</code>, and expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for allocations of data for internal use, must satisfy C++ named requirements of <code>Allocator</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. <code>d(p)</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e22d480a18565108ba4c8c1eca23d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e22d480a18565108ba4c8c1eca23d3e">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[9/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename Deleter , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a379eceb13c50cc6c7992a740d313be71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379eceb13c50cc6c7992a740d313be71">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[10/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Deleter , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> with no managed but has specified deleter and allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of specified allocator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>nullptr. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to use to destroy the object, must be <code>CopyConstructible</code>, and expression d(ptr) must be well formed, have well-defined behavior and not throw any exceptions. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for allocations of data for internal use, must satisfy C++ named requirements of <code>Allocator</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. d(p) is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a367e171bf3361b48ed95e6270194c230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367e171bf3361b48ed95e6270194c230">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[11/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The aliasing constructor: constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership information with the initial value of <code>other</code>, but holds an unrelated and unmanaged pointer <code>p</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input shared pointer. </td></tr>
    <tr><td class="paramname">U</td><td>Type of input object, U must implicitly convertible to T. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Input <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to share ownership from. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to an object to manage.</td></tr>
  </table>
  </dd>
</dl>
<p>If this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by other. However, calling <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> on this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will always return a copy of <code>p</code>. It is the responsibility of the programmer to make sure that this pointer remains valid as long as this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> exists, such as in the typical use cases where 'p' is a member of the object managed by <code>other</code> or is an alias (e.g., downcast) of <code>other.get()</code> after the call. </p>

</div>
</div>
<a id="a072e6fb202b3c2997ebbb1077b081c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072e6fb202b3c2997ebbb1077b081c51">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[12/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The aliasing constructor: constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership information with the initial value of <code>other</code>, but holds an unrelated and unmanaged pointer <code>p</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input shared pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Input <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to share ownership from. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to an object to manage.</td></tr>
  </table>
  </dd>
</dl>
<p>If this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> is the last of the group to go out of scope, it will call the stored deleter for the object originally managed by other. However, calling <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> on this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will always return a copy of <code>p</code>. It is the responsibility of the programmer to make sure that this pointer remains valid as long as this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> exists, such as in the typical use cases where 'p' is a member of the object managed by <code>other</code> or is an alias (e.g., downcast) of <code>other.get()</code> after the call. </p>

</div>
</div>
<a id="ad36edf09caa36c378ba48ea590d44a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36edf09caa36c378ba48ea590d44a1c">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[13/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bd81e7ac3b7b8df76f1a7a3cb0a0675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd81e7ac3b7b8df76f1a7a3cb0a0675">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[14/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor, constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to share the ownership from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5395b575b7d4986b4015cf0f40acf521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5395b575b7d4986b4015cf0f40acf521">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[15/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor, constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to share the ownership from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab132eaebbfed69cdbed2cea9bac5a6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab132eaebbfed69cdbed2cea9bac5a6fb">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[16/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor, move-constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. After the construction, <code>*this</code> contains a copy of the previous state of <code>other</code>, <code>other</code> is empty and its stored pointer is null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to acquire the ownership from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edea86a1d2ae32b9c6338845df0d7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edea86a1d2ae32b9c6338845df0d7ff">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[17/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor, move-constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. After the construction, <code>*this</code> contains a copy of the previous state of <code>other</code>, <code>other</code> is empty and its stored pointer is null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to acquire the ownership from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cda9d15e5fd60a5d46cb7d4cee88ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cda9d15e5fd60a5d46cb7d4cee88ca6">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[18/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another weak pointer to share the ownership to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>other.lock()</code> may be used for the same purpose: the difference is that this constructor throws an exception if the argument is empty, while <code><a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a>&lt;T&gt;::lock()</code> constructs an empty <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> in that case. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_weak_ptr</td><td>Throw if <code>other.expired() == true</code> The constructor has no effect in this case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6e1ac8e71bc6796e53de60085b8ecf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e1ac8e71bc6796e53de60085b8ecf1">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[19/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>, and provide read-write lock guard for memory safety. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another <code>std::shared</code> pointer to share the ownership to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Only pointer operations with <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> are gauranteed memory safe, operations with existing <code>std::shared_ptr</code> are still without gaurantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc15db659b2b872ed46477cfc3d1332f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc15db659b2b872ed46477cfc3d1332f">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[20/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9ba6ee332573200c08414d767f9dc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ba6ee332573200c08414d767f9dc8f">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[21/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. After the construction, <code>*this</code> contains a copy of the previous state of <code>other</code>, <code>other</code> is empty and its stored pointer is null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to acquire the ownership from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a958664e996699c404b7e5f0c213af58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958664e996699c404b7e5f0c213af58c">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[22/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_base_of&lt; <a class="el" href="class_memory_1_1_enable_safe_shared_from_this.html">EnableSafeSharedFromThis</a>&lt; Y &gt;, Y &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6591b6b5ddc20621a5640916c5a0aafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6591b6b5ddc20621a5640916c5a0aafb">&#9670;&nbsp;</a></span>SafeSharedPtr() <span class="overload">[23/23]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::weak_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> which shares ownership of the object managed by <code>other</code>. and provide read-write lock guard for memory safety. If <code>other</code> manages no object, <code>*this</code> manages no object too. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another weak pointer to share the ownership to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Only pointer operations with <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> are gauranteed memory safe, operations with existing <code>std::shared_ptr</code> are still without gaurantee. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>other.lock()</code> may be used for the same purpose: the difference is that this constructor throws an exception if the argument is empty, while <code>std::weak_ptr&lt;T&gt;::lock()</code> constructs an empty <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> in that case. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_weak_ptr</td><td>Throw if <code>other.expired() == true</code> The constructor has no effect in this case. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7382cdc4495e3a92acbe7dbde40a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7382cdc4495e3a92acbe7dbde40a70c">&#9670;&nbsp;</a></span>~SafeSharedPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::~<a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, destructs the owned object if no more <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> link to it. </p>
<p>If <code>*this</code> owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, the object is destroyed through the owned deleter. After the destruction, the shared pointers that shared ownership with <code>*this</code>, if any, will report a <a class="el" href="class_memory_1_1_safe_shared_ptr.html#aa0193148c36b6146d578eda25f501995" title="Returns the number of SafeSharedPtr objects referring to the same managed object.">use_count()</a> that is one less than its previous value. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a38fd5594f4062ed48ad5a03df76ebf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38fd5594f4062ed48ad5a03df76ebf96">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shares ownership of the object managed by <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to share the ownership to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with same object managed by <code>other</code>.</dd></dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(other).swap(*this)</code>.<br />
 If <code>other</code> manages no object, <code>*this</code> manages no object too.<br />
 Replaces the managed object with the one managed by <code>other</code>. If *this already owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, and <code>other</code> is not the same as <code>*this</code>, the object is destroyed through the owned deleter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428" title="Releases the ownership of the managed object, if any. After the call, *this manages no object.">reset</a> </dd></dl>

</div>
</div>
<a id="a496e77475a80eae8f017252228b3a64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496e77475a80eae8f017252228b3a64f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to acquire the ownership from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with same object managed by <code>other</code>.</dd></dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(std::move(other)).swap(*this)</code>.<br />
 After the assignment, <code>*this</code> contains a copy of the previous state of <code>other</code>, and <code>other</code> is empty.<br />
 Replaces the managed object with the one managed by <code>other</code>. If *this already owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, and <code>other</code> is not the same as <code>*this</code>, the object is destroyed through the owned deleter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428" title="Releases the ownership of the managed object, if any. After the call, *this manages no object.">reset</a> </dd></dl>

</div>
</div>
<a id="ac7bf58f3bb1d7220bf5f52c7cd65a721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bf58f3bb1d7220bf5f52c7cd65a721">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shares ownership of the object managed by <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to share the ownership to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with same object managed by <code>other</code>.</dd></dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(other).swap(*this)</code>.<br />
 If <code>other</code> manages no object, <code>*this</code> manages no object too.<br />
 Replaces the managed object with the one managed by <code>other</code>. If *this already owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, and <code>other</code> is not the same as <code>*this</code>, the object is destroyed through the owned deleter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428" title="Releases the ownership of the managed object, if any. After the call, *this manages no object.">reset</a> </dd></dl>

</div>
</div>
<a id="ab585d0ffe2278eb35e865a9cfa103877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab585d0ffe2278eb35e865a9cfa103877">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to acquire the ownership from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with same object managed by <code>other</code>.</dd></dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(std::move(other)).swap(*this)</code>.<br />
 After the assignment, <code>*this</code> contains a copy of the previous state of <code>other</code>, and <code>other</code> is empty.<br />
 Replaces the managed object with the one managed by <code>other</code>. If *this already owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, and <code>other</code> is not the same as <code>*this</code>, the object is destroyed through the owned deleter. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428" title="Releases the ownership of the managed object, if any. After the call, *this manages no object.">reset</a> </dd></dl>

</div>
</div>
<a id="a5a926e8afddb5a17f1bef75fc80a7cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a926e8afddb5a17f1bef75fc80a7cfb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shares ownership of the object managed by <code>other</code>, and provide read-write lock guard for memory safety. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to share the ownership to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with same object managed by <code>other</code>.</dd></dl>
<p>If <code>other</code> manages no object, <code>*this</code> manages no object too.<br />
 Replaces the managed object with the one managed by <code>other</code>. If *this already owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, and <code>other</code> is not the same as <code>*this</code>, the object is destroyed through the owned deleter. </p><dl class="section warning"><dt>Warning</dt><dd>Only pointer operations with <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> are gauranteed memory safe, operations with existing <code>std::shared_ptr</code> are still without gaurantee. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428" title="Releases the ownership of the managed object, if any. After the call, *this manages no object.">reset</a> </dd></dl>

</div>
</div>
<a id="a944ac1ce9d6c0e192137da2a9aef0851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a944ac1ce9d6c0e192137da2a9aef0851">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt;T&gt;&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> from <code>other</code>, provide read-write lock guard for memory safety. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to acquire the ownership from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> with same object managed by <code>other</code>.</dd></dl>
<p>After the assignment, <code>*this</code> contains a copy of the previous state of <code>other</code>, and <code>other</code> is empty.<br />
 Replaces the managed object with the one managed by <code>other</code>. If *this already owns an object and it is the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> owning it, and <code>other</code> is not the same as <code>*this</code>, the object is destroyed through the owned deleter. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae04ef16994300ab38b8890f617780428" title="Releases the ownership of the managed object, if any. After the call, *this manages no object.">reset</a> </dd></dl>

</div>
</div>
<a id="ae04ef16994300ab38b8890f617780428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04ef16994300ab38b8890f617780428">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the ownership of the managed object, if any. After the call, <code>*this</code> manages no object. </p>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a62318214fc139ad8294ef6e36848413f" title="Default constructor, construct a SafeSharedPtr with no managed object, i.e. empty SafeSharedPtr.">SafeSharedPtr()</a>.swap(*this)</code>.<br />
 If <code>*this</code> already owns an object and it is the last <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> owning it, the object is destroyed through the owned deleter. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="ae887a60a677dd18f1c971312a3c8c2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae887a60a677dd18f1c971312a3c8c2f5">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. Uses the delete expression as the deleter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. A valid delete expression must be available, i.e. <code>delete ptr</code> must be well formed, have well-defined behavior and not throw any exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to an object to acquire ownership of.</td></tr>
  </table>
  </dd>
</dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(ptr).swap(*this)</code>.<br />
 Replaces the managed object with an object pointed to by <code>ptr</code>. By default, delete expression is used as deleter. Proper delete expression corresponding to the supplied type is always selected, this is the reason why the function is implemented as template using a separate parameter <code>Y</code>.<br />
 If <code>*this</code> already owns an object and it is the last <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> owning it, the object is destroyed through the owned deleter.<br />
 If the object pointed to by <code>ptr</code> is already owned, the function results in undefined behavior. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. <code>delete ptr</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="ae23bf67de01d20722d835dc9f92628b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23bf67de01d20722d835dc9f92628b7">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename Deleter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. Uses the specified deleter <code>d</code> as the deleter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. Deleter must be callable for the type <code>T</code>, i.e. <code>d(ptr)</code> must be well formed, have well-defined behavior and not throw any exceptions. Deleter must be <b>CopyConstructible</b>, and its copy constructor and destructor must not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to an object to acquire ownership of. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to store for deletion of the object.</td></tr>
  </table>
  </dd>
</dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(ptr, d).swap(*this)</code>.<br />
 Replaces the managed object with an object pointed to by <code>ptr</code>. Optional deleter <code>d</code> is supplied, which is later used to destroy the new object when no <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> objects own it.<br />
 If <code>*this</code> already owns an object and it is the last <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> owning it, the object is destroyed through the owned deleter.<br />
 If the object pointed to by <code>ptr</code> is already owned, the function results in undefined behavior. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. <code>d(ptr)</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="a8c509c7adb21d071492179e5e018436c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c509c7adb21d071492179e5e018436c">&#9670;&nbsp;</a></span>reset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename Deleter , typename Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Deleter&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alloc&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the managed object with an object pointed to by ptr. Uses the specified deleter <code>d</code> as the deleter. Uses a copy of alloc for allocation of data for internal use. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of input pointer. </td></tr>
    <tr><td class="paramname">Deleter</td><td>Type of specified deleter. Deleter must be callable for the type <code>T</code>, i.e. <code>d(ptr)</code> must be well formed, have well-defined behavior and not throw any exceptions. Deleter must be <b>CopyConstructible</b>, and its copy constructor and destructor must not throw exceptions. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of specified allocator. Alloc must satisfy C++ named requirements of <code>Allocator</code>. The copy constructor and destructor must not throw exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to an object to acquire ownership of. </td></tr>
    <tr><td class="paramname">d</td><td>Deleter to store for deletion of the object. </td></tr>
    <tr><td class="paramname">alloc</td><td>Allocator to use for allocations of data for internal use, must satisfy C++ named requirements of <code>Allocator</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Equivalent to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(ptr, d, alloc).swap(*this)</code>.<br />
 Replaces the managed object with an object pointed to by <code>ptr</code>. Optional deleter <code>d</code> is supplied, which is later used to destroy the new object when no <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> objects own it.<br />
 If <code>*this</code> already owns an object and it is the last <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> owning it, the object is destroyed through the owned deleter.<br />
 If the object pointed to by <code>ptr</code> is already owned, the function results in undefined behavior. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>If read-write lock could not be obtained. May throw implementation-defined exception for other errors. <code>delete lck</code> is called if an exception occurs.<br />
 If required additional memory could not be obtained. May throw implementation-defined exception for other errors. <code>d(ptr)</code> is called if an exception occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator= </dd></dl>

</div>
</div>
<a id="aaffa1031dbd8a12bc24b846f4d374be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffa1031dbd8a12bc24b846f4d374be3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exchanges the contents of <code>*this</code> and <code>other</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another shared pointer to exchange the contents with.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b><br />
 Constant. </p>

</div>
</div>
<a id="a8200a5e400aeacdfba8254c56ecf26a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8200a5e400aeacdfba8254c56ecf26a3">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a22607aa4670e8d5b16ec3b4055a6f424">element_type</a>* <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the stored pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>The stored pointer. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>A <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> may share ownership of an object while storing a pointer to another object. <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a></code> returns the stored pointer, not the managed pointer. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Thread safety is not gauranteed with this method, call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> / <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a> before <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>, and call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> / <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> when finished. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator*, operator-&gt; </dd></dl>

</div>
</div>
<a id="a0d9eb632586e9ecd46df445ae1acc081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9eb632586e9ecd46df445ae1acc081">&#9670;&nbsp;</a></span>operator *() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ref_helper.html">RefHelper</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer, guard it with <b>write lock</b>. The behavior is undefined if the stored pointer is null. </p>
<dl class="section return"><dt>Returns</dt><dd>A temporary object provides proxy to dereferencing the stored pointer, with <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> on destruction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="ad63b2673f6dd4ea6a8ea8d1e6a78d587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63b2673f6dd4ea6a8ea8d1e6a78d587">&#9670;&nbsp;</a></span>operator *() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ref_helper.html">RefHelper</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer, guard it with <b>read lock</b>. The behavior is undefined if the stored pointer is null. </p>
<dl class="section return"><dt>Returns</dt><dd>A temporary object provides proxy to dereferencing the stored pointer, with <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> on destruction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="a279d36432aa9b9a9875a45a1dcbbd158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279d36432aa9b9a9875a45a1dcbbd158">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ptr_helper.html">PtrHelper</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer, guard it with <b>write lock</b>. The behavior is undefined if the stored pointer is null. </p>
<dl class="section return"><dt>Returns</dt><dd>A temporary object provides proxy to the stored pointer, with <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> on destruction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="a28c50f396e82c71677d138aaa535129b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c50f396e82c71677d138aaa535129b">&#9670;&nbsp;</a></span>operator-&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_ptr_helper.html">PtrHelper</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dereferences the stored pointer, guard it with <b>read lock</b>. The behavior is undefined if the stored pointer is null. </p>
<dl class="section return"><dt>Returns</dt><dd>A temporary object provides proxy to the stored pointer, with <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> on destruction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="ab1b904d3fde170a4984aa5668009c7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b904d3fde170a4984aa5668009c7fd">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_array_helper.html">ArrayHelper</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides indexed access to the stored array, guard it with <b>write lock</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary object provides proxy to the idx-th element of the array, with <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> on destruction.</dd></dl>
<p>The behavior is undefined if the stored pointer is null or if <code>idx</code> is negative.<br />
 If <code>T</code> (the template parameter of <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>) is an array type <code>U[N]</code>, <code>idx</code> must be less than <code>N</code>, otherwise the behavior is undefined.<br />
 When <code>T</code> is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. </p><dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="a5ea86c8dcc5ad23decbddc4cf0fa3772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea86c8dcc5ad23decbddc4cf0fa3772">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_memory_1_1_safe_shared_ptr_1_1_array_helper.html">ArrayHelper</a>&amp; <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides indexed access to the stored array, guard it with <b>read lock</b>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A temporary object provides proxy to the idx-th element of the array, with <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> on destruction.</dd></dl>
<p>The behavior is undefined if the stored pointer is null or if <code>idx</code> is negative.<br />
 If <code>T</code> (the template parameter of <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>) is an array type <code>U[N]</code>, <code>idx</code> must be less than <code>N</code>, otherwise the behavior is undefined.<br />
 When <code>T</code> is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="aa0193148c36b6146d578eda25f501995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0193148c36b6146d578eda25f501995">&#9670;&nbsp;</a></span>use_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::use_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> objects referring to the same managed object. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> instances managing the current object or 0 if there is no managed object.</dd></dl>
<p>Returns the number of different <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> instances (this included) managing the current object. If there is no managed object, 0 is returned.<br />
 In multithreaded environment, the value returned by use_count is approximate (typical implementations use a <code>memory_order_relaxed</code> load) </p><dl class="section note"><dt>Note</dt><dd>Common use cases include:<br />
<ul>
<li>Comparison with 0. If use_count returns zero, the shared pointer is empty and manages no objects (whether or not its stored pointer is null). In multithreaded environment, this does not imply that the destructor of the managed object has completed.</li>
<li>Comparison with 1. If use_count returns 1, there are no other owners. In multithreaded environment, this does not imply that the object is safe to modify because accesses to the managed object by former shared owners may not have completed, and because new shared owners may be introduced concurrently, such as by <a class="el" href="class_memory_1_1_safe_weak_ptr.html#a288477018d372f0888f60815328769d9" title="Creates a SafeSharedPtr that manages the referenced object.">SafeWeakPtr::lock</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ab4f3d84c401dc5458ddb7b2409ab1a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f3d84c401dc5458ddb7b2409ab1a95">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if *this stores a non-null pointer, i.e. whether <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> != nullptr</code>. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> stores a pointer, <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>An empty <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> (where <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html#aa0193148c36b6146d578eda25f501995" title="Returns the number of SafeSharedPtr objects referring to the same managed object.">use_count()</a> == 0</code>) may store a non-null pointer accessible by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>, e.g. if it were created using the aliasing constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="a13bcc785c0d40055626647380c03c5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13bcc785c0d40055626647380c03c5be">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>The type of input operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> precedes other, <code>false</code> otherwise. Common implementations compare the addresses of the control blocks.</dd></dl>
<p>The order is such that two shared pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> are different (e.g. because they point at different subobjects within the same object) <br />
 This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

</div>
</div>
<a id="a31c5707b80a33b6dd4c27cb828aa7e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c5707b80a33b6dd4c27cb828aa7e7f">&#9670;&nbsp;</a></span>owner_before() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::owner_before </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_weak_ptr.html">SafeWeakPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether this <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> precedes other in implementation defined owner-based (as opposed to value-based) order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>The type of input operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>*this</code> precedes other, <code>false</code> otherwise. Common implementations compare the addresses of the control blocks.</dd></dl>
<p>The order is such that two shared pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a> are different (e.g. because they point at different subobjects within the same object) <br />
 This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through std::owner_less. </p>

</div>
</div>
<a id="a9054feae00b20d15e00879a49e683d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9054feae00b20d15e00879a49e683d69">&#9670;&nbsp;</a></span>lock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::lock_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the lock for reading. This function will block the current thread if another thread has locked for writing. </p>
<p>Multiply readers in different thread can lock_shared at same time.<br />
 It is not possible to lock for read if the thread already has locked for write. </p><dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Read-write lock is <code>NOT</code> recursive, locking multiply times in same thread will cause block. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared</a> </dd></dl>

</div>
</div>
<a id="ae148778e9c3ac646541964ad048538b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae148778e9c3ac646541964ad048538b2">&#9670;&nbsp;</a></span>unlock_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::unlock_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the read lock. </p>
<p>Attempting to unlock a lock that is not locked is an error, and will result in undefined behaviour. </p><dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared</a> </dd></dl>

</div>
</div>
<a id="a0489e2c856bdae027f8a9f58c9b012f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0489e2c856bdae027f8a9f58c9b012f3">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the lock for writing. This function will block the current thread if another thread (including the current) has locked for reading or writing. </p>
<p>Only <code>one</code> write can lock at same time.<br />
 It is not possible to lock for read if the thread already has locked for write. </p><dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Read-write lock is <code>NOT</code> recursive, locking multiply times in same thread will cause block. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock</a> </dd></dl>

</div>
</div>
<a id="a2e8ba57f44e791d30ee35b9b7e368a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8ba57f44e791d30ee35b9b7e368a3b">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the write lock. </p>
<p>Attempting to unlock a lock that is not locked is an error, and will result in undefined behaviour. </p><dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock</a> </dd></dl>

</div>
</div>
<a id="a14f12fe979b880a62a790a4111d456d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f12fe979b880a62a790a4111d456d6">&#9670;&nbsp;</a></span>shared_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a94dd72f327e72c8aff63ab8a97b0895e">SharedLock</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::shared_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a RAII guard for read lock, it will call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared()</a> on destruction. </p>
<dl class="section return"><dt>Returns</dt><dd>RAII guard for read lock </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a9054feae00b20d15e00879a49e683d69" title="Locks the lock for reading. This function will block the current thread if another thread has locked ...">lock_shared</a>, <a class="el" href="class_memory_1_1_safe_shared_ptr.html#ae148778e9c3ac646541964ad048538b2" title="Unlocks the read lock.">unlock_shared</a> </dd></dl>

</div>
</div>
<a id="a49b16495f58c9d1c30f2a14d54d5a98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b16495f58c9d1c30f2a14d54d5a98c">&#9670;&nbsp;</a></span>unique_lock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a3073aba790f930cb0036209d01c74e52">UniqueLock</a> <a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt;::unique_lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a RAII guard for write lock, it will call <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock()</a> on construction and <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock()</a> on destruction. </p>
<dl class="section return"><dt>Returns</dt><dd>RAII write for read lock </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method is thread-safe. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a0489e2c856bdae027f8a9f58c9b012f3" title="Locks the lock for writing. This function will block the current thread if another thread (including ...">lock</a>, <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a2e8ba57f44e791d30ee35b9b7e368a3b" title="Unlocks the write lock.">unlock</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac2f2567609b6d0f0fa7e001f08497d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f2567609b6d0f0fa7e001f08497d0e">&#9670;&nbsp;</a></span>make_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; make_shared </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared pointer that manages a new object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to be created. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments in constructor of <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>List of arguments with which an instance of <code>T</code> will be constructed.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs an object of type <code>T</code> and wraps it in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> using <code>args</code> as the parameter list for the constructor of <code>T</code>. The object is constructed as if by the expression <code>::new (pv) T(std::forward&lt;Args&gt;(args)...)</code>, where pv is an internal <code>void*</code> pointer to storage suitable to hold an object of type <code>T</code>. The storage is typically larger than <code>sizeof(T)</code> in order to use one allocation for both the control block of the shared pointer and the <code>T</code> object. The <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> constructor called by this function enables `<code>shared_from_this</code> with a pointer to the newly constructed object of type <code>T</code>.<br />
 The object will be destroyed by <code>p-&gt;~X()</code>, where p is a pointer to the object and <code>X</code> is its type. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>May throw std::bad_alloc or any exception thrown by the constructor of <code>T</code>. If an exception is thrown, the functions have no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A constructor enables <code>std::enable_shared_from_this</code> with a pointer ptr of type <code>U*</code> means that it determines if <code>U</code> has a base class that is a specialization of <code>std::enable_shared_from_this</code>, and if so, the constructor evaluates the statement:<br />
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (ptr != <span class="keyword">nullptr</span> &amp;&amp; ptr-&gt;weak_this.expired())</div><div class="line">  ptr-&gt;weak_this = std::shared_ptr&lt;std::remove_cv_t&lt;U&gt;&gt;(*<span class="keyword">this</span>,</div><div class="line">                                   const_cast&lt;std::remove_cv_t&lt;U&gt;*&gt;(ptr));</div></div><!-- fragment --> Where <code>weak_this</code> is the hidden mutable <code>std::weak_ptr</code> member of <code>std::shared_from_this</code>. The assignment to the <code>weak_this</code> member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to <code>shared_from_this()</code> would share ownership with the <code>shared_ptr</code> created by this raw pointer constructor.<br />
 The test <code>ptr-&gt;weak_this.expired()</code> in the exposition code above makes sure that <code>weak_this</code> is not reassigned if it already indicates an owner. This test is required as of C++17.<br />
 <br />
 This function may be used as an alternative to <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(new T(args...))</code>. The trade-offs are: <br />
<ul>
<li><code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(new T(args...))</code> performs at least two allocations (one for the object <code>T</code> and one for the control block of the shared pointer), while make_shared&lt;T&gt; typically performs only one allocation (the standard recommends, but does not require this, all known implementations do this)<br />
</li>
<li>If any <a class="el" href="class_memory_1_1_safe_weak_ptr.html" title="Wrapper to std::weak_ptr to provide weak reference for SafeSharedPtr.">SafeWeakPtr</a> references the control block created by make_shared after the lifetime of all shared owners ended, the memory occupied by <code>T</code> persists until all weak owners get destroyed as well, which may be undesirable if <code>sizeof(T)</code> is large.</li>
<li><code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(new T(args...))</code> may call a non-public constructor of <code>T</code> if executed in context where it is accessible, while make_shared requires public access to the selected constructor.<br />
</li>
<li>Unlike the <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> constructors, make_shared does not allow a custom deleter.<br />
</li>
<li>make_shared uses <code>::new</code>, so if any special behavior has been set up using a class-specific operator new, it will differ from <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(new T(args...))</code>.<br />
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a185b0281caedef04ec18b523c389f3c3" title="Creates a shared pointer that manages a new object allocated using an allocator.">allocate_shared</a> </dd></dl>

</div>
</div>
<a id="a185b0281caedef04ec18b523c389f3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185b0281caedef04ec18b523c389f3c3">&#9670;&nbsp;</a></span>allocate_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Alloc , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; allocate_shared </td>
          <td>(</td>
          <td class="paramtype">const Alloc &amp;&#160;</td>
          <td class="paramname"><em>alloc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a shared pointer that manages a new object allocated using an allocator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to be created. </td></tr>
    <tr><td class="paramname">Alloc</td><td>Type of input allocator. </td></tr>
    <tr><td class="paramname">Args</td><td>Types of arguments in constructor of <code>T</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc</td><td>The Allocator to use. </td></tr>
    <tr><td class="paramname">args</td><td>List of arguments with which an instance of <code>T</code> will be constructed.</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs an object of type <code>T</code> and wraps it in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> using args as the parameter list for the constructor of <code>T</code>. The object is constructed as if by the expression <code>std::allocator_traits&lt;A2&gt;::construct(a, pv, v)</code>, where <code>pv</code> is an internal <code>void*</code> pointer to storage suitable to hold an object of type <code>T</code> and a is a copy of the allocator rebound to <code>std::remove_cv_t&lt;T&gt;</code>. The storage is typically larger than <code>sizeof(T)</code> in order to use one allocation for both the control block of the shared pointer and the <code>T</code> object. The <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> constructor called by this function enables <code>shared_from_this</code> with a pointer to the newly constructed object of type <code>T</code>. All memory allocation is done using a copy of alloc, which must satisfy the Allocator requirements.<br />
 For allocate_shared, the object are destroyed via the expression <code>std::allocator_traits&lt;A2&gt;::destroy(a, p)</code>, where <code>p</code> is a pointer to the object and <code>a</code> is a copy of the allocator passed to allocate_shared, rebound to the type of the object being destroyed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UserDefined</td><td>Can throw the exceptions thrown from <code>Alloc::allocate()</code> or from the constructor of <code>T</code>. If an exception is thrown, this function has no effect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Like make_shared, this function typically performs only one allocation, and places both the <code>T</code> object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of alloc is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero. <br />
 Unlike the <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> constructors, allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the <code>T</code> object, and for deallocation of their shared memory block.<br />
 A constructor enables <code>shared_from_this</code> with a pointer ptr of type <code>U*</code> means that it determines if <code>U</code> has a base class that is a specialization of <code>std::enable_shared_from_this</code>, and if so, the constructor evaluates the statement: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (ptr != <span class="keyword">nullptr</span> &amp;&amp; ptr-&gt;weak_this.expired())</div><div class="line">  ptr-&gt;weak_this = std::shared_ptr&lt;std::remove_cv_t&lt;U&gt;&gt;(*<span class="keyword">this</span>,</div><div class="line">                                   const_cast&lt;std::remove_cv_t&lt;U&gt;*&gt;(ptr));</div></div><!-- fragment --> Where <code>weak_this</code> is the hidden mutable <code>std::weak_ptr</code> member of <code>std::shared_from_this</code>. The assignment to the <code>weak_this</code> member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to <code>shared_from_this()</code> would share ownership with the <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created by this raw pointer constructor.<br />
 The test <code>ptr-&gt;weak_this.expired()</code> in the exposition code above makes sure that <code>weak_this</code> is not reassigned if it already indicates an owner. This test is required as of C++17. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#ac2f2567609b6d0f0fa7e001f08497d0e" title="Creates a shared pointer that manages a new object.">make_shared</a> </dd></dl>

</div>
</div>
<a id="a4dea18ba7a29f4a2760beee3279ab567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dea18ba7a29f4a2760beee3279ab567">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies static_cast to the stored pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to cast to. </td></tr>
    <tr><td class="paramname">U</td><td>Type to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SafeSharedPtr&lt;T&gt; casted from type <code>U</code>.</dd></dl>
<p>Creates a new instance of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> whose stored pointer is obtained from <code>r</code>'s stored pointer using a cast expression.<br />
 If <code>r</code> is empty, so is the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> (but its stored pointer is not necessarily null). Otherwise, the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will share ownership with the initial value of <code>r</code>.<br />
 Let <code>Y</code> be <code>typename std::shared_ptr&lt;T&gt;::element_type</code>, then the resulting <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>'s stored pointer will be obtained by evaluating, respectively: <code>static_cast&lt;Y*&gt;(r.get())</code>.<br />
 The behavior is undefined unless <code>static_cast&lt;T*&gt;((U*)nullptr)</code> is well formed. </p><dl class="section note"><dt>Note</dt><dd>The expression <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(static_cast&lt;T*&gt;(r.get()))</code> might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! </dd></dl>

</div>
</div>
<a id="a1118482869ccf73f0a83d2e5cf976c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1118482869ccf73f0a83d2e5cf976c68">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies dynamic_cast to the stored pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to cast to. </td></tr>
    <tr><td class="paramname">U</td><td>Type to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SafeSharedPtr&lt;T&gt; casted from type <code>U</code>.</dd></dl>
<p>Creates a new instance of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> whose stored pointer is obtained from <code>r</code>'s stored pointer using a cast expression.<br />
 If <code>r</code> is empty, so is the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> (but its stored pointer is not necessarily null). Otherwise, the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will share ownership with the initial value of <code>r</code>, except that it is empty if the <code>dynamic_cast</code> performed by dynamic_pointer_cast returns a null pointer.<br />
 Let <code>Y</code> be <code>typename std::shared_ptr&lt;T&gt;::element_type</code>, then the resulting <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>'s stored pointer will be obtained by evaluating, respectively: <code>dynamic_cast&lt;Y*&gt;(r.get())</code> (If the result of the <code>dynamic_cast</code> is a null pointer value, the returned <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will be empty). The behavior is undefined unless <code>dynamic_cast&lt;T*&gt;((U*)nullptr)</code> is well formed. </p><dl class="section note"><dt>Note</dt><dd>The expression <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(dynamic_cast&lt;T*&gt;(r.get()))</code> might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! </dd></dl>

</div>
</div>
<a id="a856963fe8204761ebecfebdcc793c041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856963fe8204761ebecfebdcc793c041">&#9670;&nbsp;</a></span>const_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies const_cast to the stored pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to cast to. </td></tr>
    <tr><td class="paramname">U</td><td>Type to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SafeSharedPtr&lt;T&gt; casted from type <code>U</code>.</dd></dl>
<p>Creates a new instance of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> whose stored pointer is obtained from <code>r</code>'s stored pointer using a cast expression.<br />
 If <code>r</code> is empty, so is the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> (but its stored pointer is not necessarily null). Otherwise, the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will share ownership with the initial value of <code>r</code>.<br />
 Let <code>Y</code> be <code>typename std::shared_ptr&lt;T&gt;::element_type</code>, then the resulting <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>'s stored pointer will be obtained by evaluating, respectively: <code>const_cast&lt;Y*&gt;(r.get())</code>. The behavior is undefined unless <code>const_cast&lt;T*&gt;((U*)nullptr)</code> is well formed. </p><dl class="section note"><dt>Note</dt><dd>The expression <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(const_cast&lt;T*&gt;(r.get()))</code> might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! </dd></dl>

</div>
</div>
<a id="a29dfd0c539b8114ba4a245b9d678172d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29dfd0c539b8114ba4a245b9d678172d">&#9670;&nbsp;</a></span>reinterpret_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; reinterpret_pointer_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies reinterpret_cast to the stored pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to cast to. </td></tr>
    <tr><td class="paramname">U</td><td>Type to cast from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SafeSharedPtr&lt;T&gt; casted from type <code>U</code>.</dd></dl>
<p>Creates a new instance of <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> whose stored pointer is obtained from <code>r</code>'s stored pointer using a cast expression.<br />
 If <code>r</code> is empty, so is the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> (but its stored pointer is not necessarily null). Otherwise, the new <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> will share ownership with the initial value of <code>r</code>.<br />
 Let <code>Y</code> be <code>typename std::shared_ptr&lt;T&gt;::element_type</code>, then the resulting <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>'s stored pointer will be obtained by evaluating, respectively: <code>reinterpret_cast&lt;Y*&gt;(r.get())</code>. The behavior is undefined unless <code>reinterpret_cast&lt;T*&gt;((U*)nullptr)</code> is well formed. </p><dl class="section note"><dt>Note</dt><dd>The expression <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;(reinterpret_cast&lt;T*&gt;(r.get()))</code> might seem to have the same effect, but they all will likely result in undefined behavior, attempting to delete the same object twice! </dd></dl>

</div>
</div>
<a id="ace42ca49c33d5133308a117c1c6ad2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace42ca49c33d5133308a117c1c6ad2b5">&#9670;&nbsp;</a></span>get_deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Deleter , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Deleter * get_deleter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the deleter of specified type, if owned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Deleter</td><td>Type of deleter returned. </td></tr>
    <tr><td class="paramname">T</td><td>Type of the object managed by <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A shared pointer whose deleter needs to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the owned deleter or <code>nullptr</code>. The returned pointer is valid at least as long as there remains at least one <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> instance that owns it.</dd></dl>
<p>Access to the <code>p</code>'s deleter. If the shared pointer <code>p</code> owns a deleter of type cv-unqualified <code>Deleter</code> (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer. </p><dl class="section note"><dt>Note</dt><dd>The returned pointer may outlive the last <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> if, for example, SafeWeakPtrs remain and the implementation doesn't destroy the deleter until the entire control block is destroyed. </dd></dl>

</div>
</div>
<a id="ac53e07f9f4e07d2d8b4a1a5d85cb3b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53e07f9f4e07d2d8b4a1a5d85cb3b47">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>lhs.get() == rhs.get()</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="af0747db920a97bbfc4b8f8e6b087126d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0747db920a97bbfc4b8f8e6b087126d">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(lhs == rhs)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a0c09d70ee247aec26a126ccbc655c20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c09d70ee247aec26a126ccbc655c20d">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::less&lt;V&gt;()(lhs.get(), rhs.get())</code>, where V is the composite pointer type of std::SafeSharedPtr&lt;T&gt;::element_type* and <code>std::shared_ptr&lt;U&gt;::element_type*</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a6b8f1945aca212b8d5ea827d4a2a3e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8f1945aca212b8d5ea827d4a2a3e4a">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>rhs &lt; lhs</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a5b89a5b6a71ad2e674074ad679c073b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b89a5b6a71ad2e674074ad679c073b5">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(rhs &lt; lhs)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a87c1fe1f0b57138c0e5081406056d348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c1fe1f0b57138c0e5081406056d348">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(lhs &lt; rhs)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a61aa5232247537b3f4a3763477a2f642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61aa5232247537b3f4a3763477a2f642">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!lhs</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a02db5c3b0da8cae814f43c085bdf2b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db5c3b0da8cae814f43c085bdf2b61">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!rhs</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a20be7a051613d73357f1f37567584af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20be7a051613d73357f1f37567584af5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(bool)lhs</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a028ab50448af1b179793f7be4c716c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ab50448af1b179793f7be4c716c65">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(bool)rhs</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> created using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a093326c04024e5295700ff8267a04059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093326c04024e5295700ff8267a04059">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::less&lt;<a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;::element_type*&gt;()(lhs.get(), nullptr)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="ad2ffa000eef3fb8d7125477cfdf6f7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ffa000eef3fb8d7125477cfdf6f7bc">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>std::less&lt;<a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a>&lt;T&gt;::element_type*&gt;()(nullptr, rhs.get())</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a6b767d7f500c119edcea607cd9ecf363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b767d7f500c119edcea607cd9ecf363">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>nullptr &lt; lhs</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="afc6b9da0ab3e08ba6699dbccbf4ad023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6b9da0ab3e08ba6699dbccbf4ad023">&#9670;&nbsp;</a></span>operator&gt;() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>rhs &lt; nullptr</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a084be4724427c94b607c083cfa5f7063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084be4724427c94b607c083cfa5f7063">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(nullptr &lt; lhs)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a7c4f2db5890e76370f2d64ab459d8f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4f2db5890e76370f2d64ab459d8f0b">&#9670;&nbsp;</a></span>operator&lt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(rhs &lt; nullptr)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a0623042e9db311b02dee5937dca19998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0623042e9db311b02dee5937dca19998">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(lhs &lt; nullptr)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>

</div>
</div>
<a id="a64d9c37e45238556d318d32bcd6c4e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d9c37e45238556d318d32bcd6c4e45">&#9670;&nbsp;</a></span>operator&gt;=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> object with another input. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of lhs. </td></tr>
    <tr><td class="paramname">U</td><td>Type of rhs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(nullptr &lt; rhs)</code>.</dd></dl>
<p>The comparison operators for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> simply compare pointer values; the actual objects pointed to are not compared. Having operator&lt; defined for <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> allows <code><a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a></code> to be used as keys in associative containers, like <code>std::map</code> and <code>std::set</code>. </p><dl class="section note"><dt>Note</dt><dd>In all cases, it is the stored pointer (the one returned by <a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get()</a>) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a SafeSharedPtrcreated using the aliasing constructor. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_memory_1_1_safe_shared_ptr.html#a8200a5e400aeacdfba8254c56ecf26a3" title="Returns the stored pointer.">get</a> </dd></dl>

</div>
</div>
<a id="a4faa671666b25d861a5ef54ac1ab6eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4faa671666b25d861a5ef54ac1ab6eba">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; U, V &gt; &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; U, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_memory_1_1_safe_shared_ptr.html">SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Outputs the value of the stored pointer to an output stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object managed by <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">SafeSharedPtr</a> </td></tr>
    <tr><td class="paramname">U</td><td>First template parameter of ostream. </td></tr>
    <tr><td class="paramname">V</td><td>Second template parameter of ostream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>A std::basic_ostream to insert ptr into. </td></tr>
    <tr><td class="paramname">ptr</td><td>The data to be inserted into os. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os</dd></dl>
<p>Inserts the value of the pointer stored in <code>ptr</code> into the output stream <code>os</code>.<br />
 Equivalent to <code>os &lt;&lt; ptr.get()</code>. </p>

</div>
</div>
<a id="a3d4444a22b9071062486cbc47d26a114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4444a22b9071062486cbc47d26a114">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_memory_1_1_safe_shared_ptr.html">Memory::SafeSharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specializes the <code>std::swap</code> algorithm. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Element type of input shared pointers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Shared pointer whose contents to swap. </td></tr>
    <tr><td class="paramname">rhs</td><td>Another shared pointer whose contents to swap.</td></tr>
  </table>
  </dd>
</dl>
<p>Specializes the <code>std::swap</code> algorithm for <a class="el" href="class_memory_1_1_safe_shared_ptr.html" title="Wrapper to std::shared_ptr to provide thread-safety while operating the underlying pointer.">Memory::SafeSharedPtr</a>. Swaps the pointers of <code>lhs</code> and <code>rhs</code>. Calls <code>lhs.swap(rhs)</code>.</p>
<p><b>Complexity</b><br />
 Constant. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Utilities/MemorySafety/<a class="el" href="_safe_shared_ptr_8hpp_source.html">SafeSharedPtr.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
